import rclpy
from rclpy.node import Node
from std_msgs.msg import Float32MultiArray, String
from rclpy.qos import QoSProfile

class RobowareNode(Node):
    def __init__(self):
        super().__init__('Roboware_node')

        # 現在のモード: 'CONTROL' または 'FOLLOW'
        self.mode = 'CONTROL'

        # QoS設定
        qos_profile = QoSProfile(depth=10)

        # サブスクライバとパブリッシャの設定
        self.command_sub = self.create_subscription(
            String,
            'web_socket_pub',
            self.command_callback,
            qos_profile
        )

        self.feedback_sub = self.create_subscription(
            Float32MultiArray,
            'RealSense_feedback',
            self.realsense_callback,
            qos_profile
        )

        self.target_pub = self.create_publisher(
            Float32MultiArray,
            'wheel_targets',
            qos_profile
        )

        # カメラデータ
        self.distance_to_person = 0.0
        self.offset_to_center = 0.0

        # タイマー
        self.timer = self.create_timer(0.1, self.publish_targets)

        self.get_logger().info("Roboware_node has started.")

    def command_callback(self, msg):
        # モード切り替え
        if msg.data == "CONTROL":
            self.mode = "CONTROL"
            self.get_logger().info("Mode switched to: CONTROL")
        elif msg.data == "FOLLOW":
            self.mode = "FOLLOW"
            self.get_logger().info("Mode switched to: FOLLOW")

    def realsense_callback(self, msg):
        # RealSenseデータを受信（距離とオフセット）
        if len(msg.data) >= 2:
            self.distance_to_person = msg.data[0]
            self.offset_to_center = msg.data[1]
            self.get_logger().info(
                f"Received RealSense data: Distance={self.distance_to_person}, Offset={self.offset_to_center}"
            )

    def publish_targets(self):
        target_msg = Float32MultiArray()

        if self.mode == "CONTROL":
            # 操縦モード：ウェブソケット経由の入力を処理（例: 制御信号を直接パススルー）
            # WebSocketからの制御は別ノードで処理しており、このノードでは直接的な制御はしない
            self.get_logger().info("CONTROL mode active: No direct targets published.")
            return

        elif self.mode == "FOLLOW":
            # 人追従モード: 距離とオフセットに基づく制御値を計算
            if self.distance_to_person < 1.0:  # 1m以内なら停止
                target_right = 0
                target_left = 0
                self.get_logger().info("Person too close, stopping.")
            else:
                # 比例制御で目標値を計算
                forward_speed = min(max(500 * (self.distance_to_person - 1.0), 0), 1000)  # 前進速度
                turn_speed = min(max(100 * self.offset_to_center, -500), 500)  # 旋回速度

                # 車輪速度の計算
                target_right = forward_speed - turn_speed
                target_left = forward_speed + turn_speed

            target_msg.data = [target_right, target_left]
            self.target_pub.publish(target_msg)

            # デバッグ用ログ
            self.get_logger().info(
                f"FOLLOW mode: Target Right={target_right}, Left={target_left}"
            )

def main(args=None):
    rclpy.init(args=args)
    node = RobowareNode()
    rclpy.spin(node)
    rclpy.shutdown()

if __name__ == '__main__':
    main()
