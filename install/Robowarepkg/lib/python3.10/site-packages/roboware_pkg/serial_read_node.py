import rclpy
from rclpy.node import Node
from std_msgs.msg import Float32MultiArray
import serial
import struct
import threading

class SerialReadNode(Node):
    def __init__(self):
        super().__init__('serial_read_node')

        # シリアルポート設定
        self.port = '/dev/ttyACM0'
        self.baudrate = 115200

        try:
            self.ser = serial.Serial(self.port, self.baudrate, timeout=0.1)
            self.get_logger().info(f"Connected to serial port: {self.port}")
        except Exception as e:
            self.get_logger().error(f"Failed to connect to serial port: {str(e)}")
            self.ser = None

        # ROSトピックへのパブリッシャ
        self.publisher = self.create_publisher(Float32MultiArray, 'wheel_feedback', 10)

        # 定期的に受信するためのスレッド
        self.read_thread = threading.Thread(target=self.continuous_read)
        self.read_thread.daemon = True
        self.read_thread.start()

    def continuous_read(self):
        while rclpy.ok() and self.ser:
            try:
                if self.ser.in_waiting >= 6:
                    data = self.ser.read(6)
                    if len(data) == 6 and data[:2] == b'\xA5\xA5':
                        _, _, right_speed, left_speed = struct.unpack('>BBhh', data)
                        msg = Float32MultiArray(data=[float(right_speed), float(left_speed)])
                        self.publisher.publish(msg)
                        self.get_logger().info(f"Feedback received: Right={right_speed}, Left={left_speed}")
                    else:
                        self.get_logger().warn(f"Unexpected data format: {data.hex()}")
            except Exception as e:
                self.get_logger().error(f"Error reading serial data: {str(e)}")

def main(args=None):
    rclpy.init(args=args)
    node = SerialReadNode()
    rclpy.spin(node)
    rclpy.shutdown()
