import rclpy
from rclpy.node import Node
from std_msgs.msg import Float32MultiArray
import serial
import struct
import time


class PIDController:
    def __init__(self, kp, ki, kd):
        self.kp = kp
        self.ki = ki
        self.kd = kd
        self.prev_error = 0.0
        self.integral = 0.0

    def compute(self, target, current, dt):
        error = target - current
        self.integral += error * dt
        derivative = (error - self.prev_error) / dt if dt > 0 else 0
        self.prev_error = error
        return self.kp * error + self.ki * self.integral + self.kd * derivative


class PIDNode(Node):
    def __init__(self):
        super().__init__('pid_node')

        # シリアルポート設定
        self.port = '/dev/ttyACM0'
        self.baudrate = 115200
        try:
            self.ser = serial.Serial(self.port, self.baudrate, timeout=0.1)
            self.get_logger().info(f"Connected to serial port: {self.port}")
        except Exception as e:
            self.get_logger().error(f"Failed to connect to serial port: {str(e)}")
            self.ser = None

        # PIDコントローラーの初期化
        self.pid_right = PIDController(kp=0.03, ki=0.1, kd=0.0)
        self.pid_left = PIDController(kp=0.03, ki=0.1, kd=0.0)

        # 初期値
        self.target_right = 0.0
        self.target_left = 0.0
        self.current_right = 0.0
        self.current_left = 0.0

        self.last_time = time.time()

        # サブスクライバー
        self.create_subscription(
            Float32MultiArray, 'wheel_targets', self.update_targets, 10)

        # タイマーでループ処理
        self.create_timer(0.01, self.control_loop)

    def update_targets(self, msg):
        if len(msg.data) >= 2:
            self.target_right, self.target_left = msg.data
            self.get_logger().info(
                f"Received targets: Right={self.target_right}, Left={self.target_left}")

    def control_loop(self):
        current_time = time.time()
        dt = current_time - self.last_time
        self.last_time = current_time

        # シリアル通信で現在値を取得
        self.read_serial_feedback()

        # PID計算
        right_control = self.pid_right.compute(
            self.target_right, self.current_right, dt)
        left_control = self.pid_left.compute(
            self.target_left, self.current_left, dt)

        # シリアル通信でモーター制御信号を送信
        self.send_serial_control(right_control, left_control)

    def read_serial_feedback(self):
        """シリアルポートからエンコーダーの速度データを読み取る"""
        if self.ser and self.ser.in_waiting >= 6:
            try:
                data = self.ser.read(6)
                if len(data) == 6 and data[:2] == b'\xA5\xA5':
                    _, _, right_speed, left_speed = struct.unpack('>BBhh', data)
                    self.current_right = float(right_speed)
                    self.current_left = float(left_speed)
                    self.get_logger().info(
                        f"Feedback received: Right={self.current_right}, Left={self.current_left}")
                else:
                    self.get_logger().warn(
                        f"Unexpected data format: {data.hex()}")
            except Exception as e:
                self.get_logger().error(
                    f"Error reading serial data: {str(e)}")

    def send_serial_control(self, right_control, left_control):
        """シリアルポートにモーター制御信号を送信する"""
        if self.ser:
            try:
                data = struct.pack(
                    '>BBhh', 0xA5, 0xA5, int(right_control), int(left_control))
                self.ser.write(data)
                self.get_logger().info(
                    f"Sent control signals: Right={right_control}, Left={left_control}")
            except Exception as e:
                self.get_logger().error(
                    f"Error sending serial data: {str(e)}")


def main(args=None):
    rclpy.init(args=args)
    node = PIDNode()
    rclpy.spin(node)
    rclpy.shutdown()
