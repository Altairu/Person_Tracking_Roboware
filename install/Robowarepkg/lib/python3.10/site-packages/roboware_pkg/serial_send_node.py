import rclpy
from rclpy.node import Node
from std_msgs.msg import Float32MultiArray
import serial
import struct
import threading
import time

class SerialSendNode(Node):
    def __init__(self):
        super().__init__('serial_send_node')

        # シリアルポート設定
        self.port = '/dev/ttyACM0'
        self.baudrate = 115200

        try:
            self.ser = serial.Serial(self.port, self.baudrate, timeout=0.1)
            self.get_logger().info(f"Connected to serial port: {self.port}")
        except Exception as e:
            self.get_logger().error(f"Failed to connect to serial port: {str(e)}")
            self.ser = None

        self.target_right = 0
        self.target_left = 0

        # ROSトピック購読
        self.create_subscription(Float32MultiArray, 'wheel_controls', self.update_targets, 10)

        # 定期的に送信するためのスレッド
        self.send_thread = threading.Thread(target=self.continuous_send)
        self.send_thread.daemon = True
        self.send_thread.start()

    def update_targets(self, msg):
        if len(msg.data) == 2:
            self.target_right = int(msg.data[0])
            self.target_left = int(msg.data[1])
            self.get_logger().info(f"Updated targets: Right={self.target_right}, Left={self.target_left}")

    def continuous_send(self):
        while rclpy.ok() and self.ser:
            try:
                data = struct.pack('>BBhh', 0xA5, 0xA5, self.target_right, self.target_left)
                self.ser.write(data)
                self.get_logger().info(f"Sent data: Right={self.target_right}, Left={self.target_left}")
            except Exception as e:
                self.get_logger().error(f"Error sending data: {str(e)}")
            time.sleep(0.05)  # 送信間隔（50ms）

def main(args=None):
    rclpy.init(args=args)
    node = SerialSendNode()
    rclpy.spin(node)
    rclpy.shutdown()
