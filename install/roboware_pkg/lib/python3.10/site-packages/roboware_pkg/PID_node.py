import rclpy
from rclpy.node import Node
from std_msgs.msg import Float32MultiArray
import time

class PIDController:
    def __init__(self, kp, ki, kd):
        self.kp = kp
        self.ki = ki
        self.kd = kd
        self.prev_error = 0
        self.integral = 0

    def compute(self, target, current, dt):
        error = target - current

        # 特別条件: 目標値と現在地が両方0なら出力を0にリセット
        if target == 0 and current == 0:
            self.reset()
            return 0

        self.integral += error * dt
        derivative = (error - self.prev_error) / dt
        self.prev_error = error

        return self.kp * error + self.ki * self.integral + self.kd * derivative

    def reset(self):
        self.prev_error = 0
        self.integral = 0

class PIDNode(Node):
    def __init__(self):
        super().__init__('PID_node')

        self.sub = self.create_subscription(
            Float32MultiArray,
            'wheel_targets',
            self.target_callback,
            10
        )

        self.pub = self.create_publisher(
            Float32MultiArray,
            'wheel_controls',
            10
        )

        # PIDコントローラーの初期化
        self.pid_right = PIDController(kp=0.03, ki=0.1, kd=0.0)
        self.pid_left = PIDController(kp=0.03, ki=0.1, kd=0.0)

        # 現在値の保持
        self.current_right = 0
        self.current_left = 0

        # タイマーで定期的にPID計算を実行
        self.timer = self.create_timer(0.01, self.control_loop)
        self.last_time = time.time()

    def target_callback(self, msg):
        if len(msg.data) >= 4:
            self.target_right = msg.data[0]
            self.target_left = msg.data[1]
            self.current_right = msg.data[2]
            self.current_left = msg.data[3]
        else:
            self.get_logger().error("Invalid data length received in wheel_targets")

    def control_loop(self):
        current_time = time.time()
        dt = current_time - self.last_time
        self.last_time = current_time

        if hasattr(self, 'target_right') and hasattr(self, 'target_left'):
            # 右車輪のPID制御
            control_signal_right = self.pid_right.compute(
                self.target_right, self.current_right, dt
            )

            # 左車輪のPID制御
            control_signal_left = self.pid_left.compute(
                self.target_left, self.current_left, dt
            )

            # 制御信号をパブリッシュ
            control_msg = Float32MultiArray()
            control_msg.data = [control_signal_right, control_signal_left]
            self.pub.publish(control_msg)

            # ログ出力
            self.get_logger().info(
                f"Target Right={self.target_right}, Left={self.target_left} | "
                f"Current Right={self.current_right}, Left={self.current_left} | "
                f"Control Right={control_signal_right}, Left={control_signal_left}"
            )
        else:
            self.get_logger().warning("No target or current values received yet.")

def main(args=None):
    rclpy.init(args=args)
    node = PIDNode()
    rclpy.spin(node)
    rclpy.shutdown()

if __name__ == '__main__':
    main()
